<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map and Set(映射和集合)</title>
</head>
<body>
    <script>
        /*
            Map 是一个带键的数据想的集合，就像一个Object一样，但是他们最大的区别是Map允许
            任何类型的键 key

            方法和属性如下：
            new Map() 创建Map
            map.set(key,value) 根据键存储值
            map.get(key) 根据键来返回值，如果map中不存在对应的key，则返回undefined
            map.has(key) 如果key存在则返回true，否则返回false
            map.delete(key) 删除指定键的值
            map.clear()  清空map
            map.size 返回当前元素个数

            map[key]不是使用Map的正确方式

            虽然有效，但是会将map视为JavaScript的plain object,因此他暗含了所有响应的限制（仅支持string/symbol键等）
            所以我们应该使用map方法 set和get
        
            Map可以使用对象作为键
            这是他和对象的区别
            let john = { name: "John" };

            // 存储每个用户的来访次数
            let visitsCountMap = new Map();

            // john 是 Map 中的键
            visitsCountMap.set(john, 123);

            alert( visitsCountMap.get(john) ); // 123

            Map是怎么比较键的
            Map使用SameValueZero算法来比较键是否相等。它和严格等于差不过，但区别是NaN被看成是等于NaN。所以NaN也可以被用作键
            这个算法不能被改变或者自定义

            链式调用：
            每一次map.set调用都会返回map自身，所以我们可以进行链式调用
            map.set('a','1').set('b',2)


            Map迭代
            如果要在map里使用循环，可以使用一下三个方法
            map.keys() 遍历并返回一个包含所有键的可迭代对象
            map.values() 遍历并返回一个包含所有值的可迭代对象
            map.entries() 遍历返回一个包含所有实体[key,value]的可迭代对象，for...of在默认情况下使用的就是这个
            map.forEach((value,key,map)=>{})
            let recipeMap = new Map([
            ['cucumber', 500],
            ['tomatoes', 350],
            ['onion',    50]
            ]);

            // 遍历所有的键（vegetables）
            for (let vegetable of recipeMap.keys()) {
            alert(vegetable); // cucumber, tomatoes, onion
            }

            // 遍历所有的值（amounts）
            for (let amount of recipeMap.values()) {
            alert(amount); // 500, 350, 50
            }

            // 遍历所有的实体 [key, value]
            for (let entry of recipeMap) { // 与 recipeMap.entries() 相同
            alert(entry); // cucumber,500 (and so on)
            }

            注意：迭代顺序与插入值的顺序相同，与普通对象不同，Map会保留此顺序
            
            Object.entries:从对象创建Map,返回值是一个可迭代对象/值对
            Object.entries可以返回一个键值对格式的数组正好可以用上

            let obj = {
                name:'张三',
                age:30
            }

            let map = new Map(Object.entries(obj))
            console.log(map.get('name'))//张三
        
            Object.formEntries()从Map或者可迭代对象创建对象
                let prices = Object.fromEntries([['banana',1],['orange',2],['meat',3]])
                console.log(prices);//{banana: 1, orange: 2, meat: 3}
            
            Set
                一个特殊的类型集合---值得集合没有键，他的每个值只出现一次
                主要方法
                new Set(iterable) 创建一个set，如果提供了一个iterable对象（通常是个数组），将会从数组中复制值到set中

                set.add(value) --添加一个值，返回set本身
                set.delete(value) --删除值，如果value在这个方法调用时存在就返回true，否则返回false
                set.has(value) 如果value在set中，返回true，否则返回false
                set.clear() 清空set
                set.size   返回元素个数

                Set迭代
                    for...of 或 forEach来遍历Set
                    forEach((value,valueAgain,set)=>{})
                    注意 value和valueAgain值是相同的

                    剩余的 .keys()/.values()/.entries(),
                    .entries()遍历并返回一个包含所有实体[value,value]的可迭代对象，
                    它的存在也是为了兼容Map
                */

                // 练习题
                function unique(arr) {
                    /* 你的代码 */
                    let set = new Set(arr)
          
                    return Array.from(set)
                }

                let values = ["Hare", "Krishna", "Hare", "Krishna",
                "Krishna", "Krishna", "Hare", "Hare", ":-O"
                ];

                // alert( unique(values) );

                // 我们期望使用 map.keys() 得到一个数组，然后使用例如 .push 等特定的方法对其进行处理。
                let map = new Map();

                map.set("name", "John");

                let keys = Array.from(map.keys());

                // Error: keys.push is not a function
                keys.push("more");
                console.log(keys);

    </script>
</body>
</html>